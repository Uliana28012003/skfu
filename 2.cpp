////Модифицируйте программу упр. 1 так, чтобы вывод родительского потока производился после завершения дочернего.Используйте pthread_join.

//#include <iostream>  
//#include <pthread.h>  // Для работы с потоками
//#include <unistd.h>  // Для функции usleep
//using namespace std;
//
//void* threadF(void*) {
//    // Функция, выполняемая в дочернем потоке
//    for (int i = 0; i < 10; ++i) {
//        cout << "Дочерний Поток: " << i << endl;
//        usleep(200000); // Имитация задержки в 200000 микросекунд (0.2 секунды)
//    }
//    pthread_exit(NULL); // Завершение потока
//}
//
//int main() {
//    setlocale(LC_ALL, "Russian"); 
//
//    // Создаем поток (с валидацией)
//    pthread_t t; // Переменная для хранения идентификатора потока
//    if (pthread_create(&t, NULL, threadF, NULL) != 0) {
//        // Если создание потока завершилось ошибкой
//        cerr << "Ошибка при создании потока" << endl;
//        return 1; // Возвращаем код ошибки
//    }
//
//    // Ждем завершения дочернего потока (с валидацией)
//    if (pthread_join(t, NULL) != 0) {
//        // Если присоединение потока завершилось ошибкой
//        cerr << "Ошибка при присоединении потока" << endl;
//        return 1; // Возвращаем код ошибки
//    }
//
//    // Вывод в родительском потоке после завершения дочернего
//    for (int i = 0; i < 10; ++i) {
//        cout << "Родительский Поток: " << i << endl;
//        usleep(200000); // Имитация задержки в 200000 микросекунд (0.2 секунды)
//    }
//
//    return 0; // Завершение программы
//}
//
