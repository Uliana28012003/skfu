////Решите задачу 11 с использованием условной переменной и минимально необходимого количества мьютексов.
//#include <iostream>
//#include <thread>
//#include <mutex>
//#include <condition_variable>
//
//using namespace std;
//
//// мьютекс для синхронизации доступа к общим ресурсам
//mutex mtx;
//// условная переменная для координации потоков
//condition_variable cv;
//// флаг для определения очередности вывода
//bool isparentturn = true; // начинаем с родительского потока
//
//// функция, которую будет выполнять дочерний поток
//void threadf() {
//    for (int i = 0; i < 10; ++i) {
//        unique_lock<mutex> lock(mtx); // захватываем мьютекс
//        cv.wait(lock, [] { return !isparentturn; }); // ждем, пока не станет очередь дочернего потока
//        cout << "дочерний поток: " << i << endl;
//        isparentturn = true; // указываем, что следующая итерация должна быть у родительского потока
//        cv.notify_one(); // сигнализируем родительскому потоку, что он может продолжить выполнение
//    }
//}
//
//int main() {
//    setlocale(lc_all, "russian");
//
//    // создаем дочерний поток
//    thread t(threadf);
//
//    for (int i = 0; i < 10; ++i) {
//        unique_lock<mutex> lock(mtx); // захватываем мьютекс
//        cv.wait(lock, [] { return isparentturn; }); // ждем, пока не станет очередь родительского потока
//        cout << "родительский поток: " << i << endl;
//        isparentturn = false; // указываем, что следующая итерация должна быть у дочернего потока
//        cv.notify_one(); // сигнализируем дочернему потоку, что он может продолжить выполнение
//    }
//
//    t.join(); // ожидаем завершения дочернего потока
//
//    return 0;
//}
